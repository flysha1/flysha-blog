---
date: 2018-01-01
category:
  - 前端技术
tag:
  - 浏览器
  - 面经
---

# 7. 事件流

事件流分为三个阶段：**捕获阶段**、**目标阶段**、**冒泡阶段**。

过程如下：

- **捕获阶段** ：事件从最外层的节点，也就是文档对象开始，逐级向下传播，直到事件的目标节点上。

- **目标阶段**：事件到达目标节点，触发目标节点上的事件处理函数。

- **冒泡阶段**：事件从目标节点开始，逐级向上传播，直到到达最外层节点（文档对象）

## 事件冒泡和捕获的区别？

事件冒泡和事件捕获是两种不同的事件传播方式，**默认是冒泡**，它们的区别在于传播方向不同：

- **事件冒泡**是从自下而上，从子元素冒泡到父元素，执行父元素上的事件处理。

- **事件捕获**是事件从文档的根元素开始，逐级向下传播到较为具体的元素（即从父元素到子元素）。

## 如何阻止事件冒泡

- 普通浏览器：```event.stopPropagation()```

- IE浏览器：```event.cancelBubble = true```

## 对事件委托的理解

利用浏览器事件冒泡机制。事件在冒泡的过程中会传到父节点，并且父节点可以通过事件对象获取到目标节点，可以吧子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件

## 对浏览器事件循环的理解

事件循环是一种机制，它会不断的轮询任务队列，并将队列中的任务依此执行。

```JavaScript``` 的任务分为两种同步和异步：

- **同步任务**：在主线程上排队执行的任务，只有一个任务执行完毕，才能执行下一个任务，

- **异步任务**：不进入主线程，而是放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到执行栈然后主线程执行调用栈的任务。

因为js是单线程，在执行代码的时候将所有函数压入执行栈中。同步任务会按照后进先出的原则依次执行。遇到异步任务时，将其放入任务队列中。当前执行栈里事件执行完毕后，就会从任务队列中取出对应异步任务的回调函数放入执行栈中继续执行。

宏观任务(MacroTask|Task)、微观任务(MicorTask)：

- **宏任务**：```script```全部代码、```setTimeout```、```setInterval```、```I/O```、UI渲染

- **微任务**：```Promise.then```、```Process.nexTick```(Node独有)、```MutationObserver```

任务队列中的任务分为宏任务和微任务，当执行栈清空后，会先检查任务队列中是否有微任务，如果有就按照先进先出的原则，压入执行栈中执行。微任务中产生了新的微任务不会推迟到下一个循环中，而是在当前循环中继续执行。 当执行这一轮的微任务完毕后，开启下一轮循环，执行任务队列中的宏任务。

**注意**：一次 ```Eventloop``` 循环会处理一个宏任务和所有这次循环中产生的微任务。

**执行顺序**

- 执行宏任务中的同步代码，遇到宏任务或微任务，分别放入对应的任务队列，等待执行。

- 当所有同步任务执行完毕后，执行栈为空，首先执行微任务队列中的任务

- 微任务执行完毕后，检查这次执行中是否产生新的微任务，如果存在，重复执行步骤，直到微任务执行完毕。

- 开始下一轮 ```Event Loop``` ，执行宏任务中的代码

## Node.js的事件循环

Node事件循环分为6个阶段，每进入一个阶段，都会去对应的回调队列中取出函数执行。

1. **Timers** 阶段：执行timer（setTimeout、setInterval）的回调，由poll阶段控制；

2. **I/O callbacks** 阶段：系统调用相关的回调

3. **idle prepare** 阶段：Nodejs内部执行，可以忽略

4. **poll** 阶段：轮询。在该阶段如果没有timer的话，会出现一下情况：

    - poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制；

    - poll队列对空，会出现以下两种情况：

        - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调；

        - 如果没有 setImmediate 回调需要执行，就会等待回调被天加到队列中，然后立即执行。
        
        - 如果设置里有timer，并且 poll 队列为空，就会判断是否有 timer 超时，如果有就回到 timers 阶段执行回调。

5. **check** 阶段：执行 setImmediate 回调

6. **colse callbacks** 阶段：执行一些关闭回调，比如socket.on('close', ...)等。

### process.nextTick

它会在轮询的各个阶段结束时，进入到下一个阶段之前立即执行。

### setImmediate 和 setTimeout

```js
setTimeout(() => {
    console.log('setTimeout')
}, 0)
setImmediate(() => {
    console.log('setImmediate')
})

```

这种情况下，定时器的执行顺序是随机的。

如果把这两个函数放入一个 ```I/O``` 循环内调用，```setImmediate``` 总是被优先调用

```js
const fs = require('fs')
fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})

// immediate
// timeout
```

## Node和浏览器事件循环机制的区别

- 浏览器事件循环会在宏任务结束后，检查微任务。而Node的微任务是在两个阶段之间执行。

- 浏览器的 ```process.nextTick``` 和其他微任务优先级一样，而node中要高于其他优先级。
