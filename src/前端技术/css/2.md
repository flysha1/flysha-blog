---
date: 2017-12-01
order: 2
category:
  - 前端技术
tag:
  - CSS
---

# 选择符与优先级

## 选择符

选择符分为五类：

- 元素选择符 Element Selectors
- 关系选择符 Relationship Selectors
- 属性选择符 Attribute Selectors
- 伪类选择符 Pseudo-Classes Selectors
- 伪元素选择符 Pseudo-Element Selectors

### 1. 元素选择符

| 选择符 | 选择符名称 | 描述 |
|---|---|---|
| `*` | 通配选择符 | 所有元素对象 |
| `E` | 类型选择符 | 以文档语言对象类型作为选择符 |
| `E#id` | ID 选择符 | 以唯一标识符 ID 属性的 E 元素作为选择符 |
| `E.class` | 类选择符 | 以 `class` 属性的 E 元素作为选择符 |

### 2. 关系选择符

| 选择符 | 选择符名称 | 描述 | CSS3 |
|---|---|---|---|
| `E F` | 包含选择符 | 选择所有被 E 元素包含的 F 元素（能命中所有后代元素）||
| `E>F` | 子选择符 | 选择所有作为 E 元素的子元素 F（只能命中子元素）||
| `E+F` | 相邻选择符 | 选择紧贴在 E 元素之后 F 元素 ||
| `E~F` | 兄弟选择符 | 选择 E 元素所有兄弟元素 F | ✅ |

### 3. 属性选择符

| 选择符 | 描述 | CSS3 |
|---|---|---|
| `E[att]` | 选择具有 `att` 属性的 E 元素。||
| `E[att='val']`  | 选择具有 `att` 属性且属性值等于 `val` 的 E 元素。||
| `E[att~='val']` | 选择具有 `att` 属性且属性值为一用空格分隔的字词列表，其中一个等于 `val` 的 E 元素。 ||
| `E[att^='val']` | 选择具有 `att` 属性且属性值为以 `val` 开头的字符串的 E 元素。 | ✅ |
| `E[att$='val']` | 选择具有 `att` 属性且属性值为以 `val` 结尾的字符串的 E 元素。 | ✅ |
| `E[att*='val']` | 选择具有 `att` 属性且属性值为包含 `val` 的字符串的 E 元素。 | ✅ |
| `E[att\|='val']` | 选择具有 `att` 属性且属性值为以 `val` 开头并用连接符 `-` 分隔的字符串的 E 元素，如果属性值仅为 `val`，也将被选择。 | |

`css
.div {
  /* 表示存在 class 属性并且以 title 开头的元素 */
  [class^='title'] {
    margin-bottom: 8px;
  }
}
`

### 4. 伪类选择符

伪类就是一个选择处于特定状态的元素的选择器，比如某个 `className` 的第一个元素，某个被 `hover` 的元素等等。我们可以理解成一个特定的 CSS 类，但与普通的类不一样，它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为 **伪类**。

| 选择符 | 描述 | CSS3 |
|---|---|---|
| `E:link` | 设置超链接 `<a>` 在未被访问前的样式。||
| `E:visited` | 设置超链接 `<a>` 在其链接地址已被访问过时的样式。||
| `E:hover` | 设置元素在其鼠标悬停时的样式。 ||
| `E:active` | 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 ||
| `E:focus` | 设置元素在成为输入焦点（该元素的 `onfocus` 事件发生）时的样式。||
| `E:lang(fr)` | 匹配使用特殊语言的 E 元素。||
| `E:not(s)` | 匹配不含有 s 选择符的元素 E。|✅|
| `E:root` | 匹配 E 元素在文档的根元素。|✅|
| `E:first-child` | 匹配父元素的第一个子元素 E。||
| `E:last-child` | 匹配父元素的最后一个子元素 E。|✅|
| `E:only-child` | 匹配父元素仅有的一个子元素 E。|✅|
| `E:nth-child(n)` | 匹配父元素的第 n 个子元素 E。|✅|
| `E:nth-last-child(n)` | 匹配父元素的倒数第 n 个子元素 E。|✅|
| `E:first-of-type` | 匹配父元素下第一个类型为 E 的子元素。|✅|
| `E:last-of-type` | 匹配父元素下的所有 E 子元素中的倒数第一个。|✅|
| `E:only-of-type` | 匹配父元素的所有子元素中唯一的那个子元素 E。|✅|
| `E:nth-of-type(n)` | 匹配父元素的第 n 个子元素 E。|✅|
| `E:nth-last-of-type(n)` | 匹配父元素的倒数第 n 个子元素 E。|✅|
| `E:empty` | 匹配没有任何子元素（包括 Text 节点）的元素 E。|✅|
| `E:checked` | 匹配用户界面上处于选中状态的元素 E。|✅|
| `E:enabled` | 匹配用户界面上处于可用状态的元素 E。|✅|
| `E:disabled` | 匹配用户界面上处于禁用状态的元素 E。|✅|
| `E:target` | 匹配相关 URL 指向的 E 元素。|✅|

```css
/* li 最后一个元素不添加边框 */
li:not(:last-child) {
  border-bottom: 1px solid black;
}

/* 与第一个 li 相连兄弟 */
li:first-child ~ li {
  border-left: 1px solid #666;
}
```

### 5. 伪元素选择符

伪元素和伪类很像，但是伪元素类似于增添一个新的 DOM 节点到 DOM 树中，而不是改变元素的状态。注意了，这里是类似，而不是真的增加一个节点，这也是其被称为伪元素的原因（实质上，元素被创建在文档流外）。

| 选择符 | 描述 | CSS3 |
|---|---|---|
| `E:first-letter / E::first-letter` | 设置元素内的第一个字符的样式。||
| `E:first-first-line / E::first-line` | 设置元素内的第一行的样式。||
| `E:before / E::before` | 设置在元素前（依据对象树的逻辑结构）发生的内容。用来和 `content` 属性一起使用。||
| `E:after / E::after` | 设置在元素后（依据对象树的逻辑结构）发生的内容。用来和 `content` 属性一起使用。||
| `E::placeholder` | 设置元素文字占位符的样式。||
| `E::selection` | 设置元素被选择时的颜色。||

> [!tip]
> CSS3 将伪元素选择符（Pseudo-Element Selectors）前面的单个冒号（`:`）修改为双冒号（`::`）用以区别伪类选择符（Pseudo-Classes Selectors），但以前的写法仍然有效。

# 优先级

浏览器通过**优先级**（也称为特殊性）来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。

## 优先级顺序

选择符优先级：

1. !important
2. 行内样式
3. ID 选择符
4. 类选择符
5. 标签选择符 | 伪类选择符 | 属性选择符
6. 伪元素选择符
7. 通配选择符 | 关系选择符 | 否定伪类

|选择符|权重值|
|---|---|
|行内样式|[1,0,0,0] A|
|ID 选择符|[0,1,0,0] B|
|类选择符、伪类选择符和属性选择符|[0,0,1,0] C|
|标签选择符和伪类对象选择符|[0,0,0,1] D|
|通配符、关系选择符和否定选择符|[0,0,0,0] E|
|继承样式|无权重值|

### 权重值比较规则

- CSS 优先级是根据由每种选择符类型构成的级连字符串计算而成的，它不是一个对应相应匹配表达式的权重值；
- [1,0,0,0] > [0,99,99,99] ***从左往右逐个等级比较，前一个等级相等才往后比较***；
- 无论是行内样式、内联样式表和外链样式表，都是按照这个规则来进行比较。而不是简单的 行内样式 > 内联样式表 > 外链样式表。之所以有这样的错觉，是因为确实行间样式为第一等的权重，所以它的权重是最高的。而内联样式可能一般写在了外链样式引用了之后，所以覆盖掉了之前的；
- 当 CSS 选择器权重相同，则最后的声明的 CSS 选择器覆盖靠前的 CSS；
- 相同 CSS 表达式，在 DOM 结构中的距离是不会对元素优先级计算产生影响的。

### !important

当在一个样式生命中使用 `!import` 规则时，此声明将覆盖任何其他声明。

::: warning 注意

使用 `!important` 是一个坏习惯，应该尽量避免，因为这破坏了样式表中的固有的级联规则 使得调试找 BUG 变得更加困难了。当两条相互冲突的带有 `!important` 规则的声明被应用到相同的元素上时，拥有更大优先级的声明将会被采用。

:::

::: important 经验法则

- 一定要优先考虑使用样式规则的优先级来解决问题而不是 `!important`
- 只有在需要覆盖全站或外链 CSS 的特定页面中使用 `!important`
- 永远不要再全站范围的 CSS 上使用 `!import`
- 永远不要在你的插件中使用 `!import`

:::
