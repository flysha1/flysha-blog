import comp from "D:/code/vuepress/flysha-blog/src/.vuepress/.temp/pages/前端技术/JavaScript/核心模块/函数声明/异步函数.html.vue"
const data = JSON.parse("{\"path\":\"/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/JavaScript/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0.html\",\"title\":\"异步函数\",\"lang\":\"zh-CN\",\"frontmatter\":{\"order\":3,\"date\":\"2018-01-01T00:00:00.000Z\",\"category\":[\"前端技术\"],\"tag\":[\"JavaScript\"],\"gitInclude\":[]},\"headers\":[{\"level\":2,\"title\":\"基本用法\",\"slug\":\"基本用法\",\"link\":\"#基本用法\",\"children\":[{\"level\":3,\"title\":\"异步函数的声明\",\"slug\":\"异步函数的声明\",\"link\":\"#异步函数的声明\",\"children\":[]},{\"level\":3,\"title\":\"异步函数的语句\",\"slug\":\"异步函数的语句\",\"link\":\"#异步函数的语句\",\"children\":[]},{\"level\":3,\"title\":\"异步语句返回值\",\"slug\":\"异步语句返回值\",\"link\":\"#异步语句返回值\",\"children\":[]}]},{\"level\":2,\"title\":\"语法\",\"slug\":\"语法\",\"link\":\"#语法\",\"children\":[{\"level\":3,\"title\":\"返回值类型\",\"slug\":\"返回值类型\",\"link\":\"#返回值类型\",\"children\":[]},{\"level\":3,\"title\":\"返回值状态变化\",\"slug\":\"返回值状态变化\",\"link\":\"#返回值状态变化\",\"children\":[]},{\"level\":3,\"title\":\"异步语句返回值\",\"slug\":\"异步语句返回值-1\",\"link\":\"#异步语句返回值-1\",\"children\":[]}]},{\"level\":2,\"title\":\"异常处理\",\"slug\":\"异常处理\",\"link\":\"#异常处理\",\"children\":[{\"level\":3,\"title\":\"捕捉异常\",\"slug\":\"捕捉异常\",\"link\":\"#捕捉异常\",\"children\":[]}]},{\"level\":2,\"title\":\"操作中断\",\"slug\":\"操作中断\",\"link\":\"#操作中断\",\"children\":[]},{\"level\":2,\"title\":\"实现原理\",\"slug\":\"实现原理\",\"link\":\"#实现原理\",\"children\":[]},{\"level\":2,\"title\":\"最佳实践\",\"slug\":\"最佳实践\",\"link\":\"#最佳实践\",\"children\":[{\"level\":3,\"title\":\"异步阻塞\",\"slug\":\"异步阻塞\",\"link\":\"#异步阻塞\",\"children\":[]},{\"level\":3,\"title\":\"异步非阻塞\",\"slug\":\"异步非阻塞\",\"link\":\"#异步非阻塞\",\"children\":[]},{\"level\":3,\"title\":\"异步并发\",\"slug\":\"异步并发\",\"link\":\"#异步并发\",\"children\":[]},{\"level\":3,\"title\":\"未知数量的异步并发\",\"slug\":\"未知数量的异步并发\",\"link\":\"#未知数量的异步并发\",\"children\":[]},{\"level\":3,\"title\":\"不等待结果的异步循环\",\"slug\":\"不等待结果的异步循环\",\"link\":\"#不等待结果的异步循环\",\"children\":[]},{\"level\":3,\"title\":\"异步串行遍历\",\"slug\":\"异步串行遍历\",\"link\":\"#异步串行遍历\",\"children\":[]},{\"level\":3,\"title\":\"异步并行遍历\",\"slug\":\"异步并行遍历\",\"link\":\"#异步并行遍历\",\"children\":[]}]}],\"readingTime\":{\"minutes\":7.12,\"words\":2135},\"filePathRelative\":\"前端技术/JavaScript/核心模块/函数声明/异步函数.md\",\"localizedDate\":\"2018年1月1日\",\"excerpt\":\"\\n<p><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用关键字 <code>async</code> 来表示，在函数内部是使用 <code>await</code> 命令来表示异步。</p>\\n<p>相较于 <code>Generator</code>，<code>async</code> 函数的改进在于以下四点：</p>\\n<ul>\\n<li>内置执行器：<code>Generator</code> 函数的执行必须靠执行器，而 <code>async</code> 函数自带执行器，调用方式与普通函数一致。</li>\\n<li>更好的语义：<code>async</code> 和 <code>await</code> 相较于星号（<code>*</code>）和 <code>yield</code> 更加语义化。<code>async</code> 表示函数中有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果。</li>\\n<li>更广的适用性：co 模块约定，<code>yield</code> 命令后面只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象，而 <code>async</code> 函数的 <code>await</code> 命令后面则可以是 <code>Promise</code> 和原始类型的值（Number、String 和 Boolean，但这时会自动转成立即 <code>fulfilled</code> 状态的 <code>Promise</code> 对象）。</li>\\n<li>返回值是 Promise：<code>async</code> 函数的返回值是 <code>Promise</code> 对象，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code> 对象方便多了。你可以用 <code>then</code> 方法指定下一步的操作。</li>\\n</ul>\"}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
